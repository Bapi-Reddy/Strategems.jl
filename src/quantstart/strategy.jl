#=
Implementation of the Quantstart event-driven backtester's strategy functionality in Julia.

See here: https://www.quantstart.com/articles/Event-Driven-Backtesting-with-Python-Part-iv
=#

@doc """
Strategy is an abstract type providing an interface to all other strategy object types.

The goal of a (derived) Strategy object is to generate Signal objects for particular symbols based on the inputs of Bars generated by a DataHandler object.

This is designed tow ork both with historic and live data as the Strategy object is agnostic to the data source, since it obtains the bar tuples from a Queue object.
""" ->
abstract Strategy


#TODO: implement for all strategy types
@doc doc"""
calculate_signals(strat::Strategy)

Provides the mechanisms to calculate the list of signals.
""" ->
function calculate_signals(strat::Strategy)
    error("Must implement calculate_signals function.")
end

@doc """
This is an extremely simple strategy that goes LONG all of the symbols as soon as a bar is received. It will never exit a position.

It is primarily used as a testing mechanism for the Strategy class as well as a benchmark upon which to compare other strategies.
""" ->
type BuyAndHoldStrategy <: Strategy
    bars::DataHandler
    events::EventQueue
    tickers::Vector{String}
    bought::Dict{String}
    function BuyAndHoldStrategy(bars::DataHandler, events::EventQueue, bought::Dict{String,Bool}=Dict{String,Bool}())
        if isempty(bought)
            for ticker in tickers
                bought[ticker] = false
            end
        end
        new(bars, events, bars.tickers, bought)
    end
end

@doc doc"""
calculate_signals(strat::BuyAndHoldStrategy, event::MarketEvent)

For 'Buy and Hold' we generate a single signal per symbol and then no additional signals. This means we are constantly long the market from the date of strategy initialization.
""" ->
function calculate_signals!(strat::BuyAndHoldStrategy, event::MarketEvent)
    for ticker in strat.tickers
        bars = get_latest_bars(strat.bars, ticker, 1)
        if bars != Void{} && !isempty(bars)  #TODO: implement isempty method for bars and ensure Void check is valid equivalent of Python's `is not None`
            if !strat.bought[ticker]
                # (Symbol, DateTime, Type=LONG/SHORT/EXIT)
                signal = SignalEvent(bars[0][0], bars[0][1], 'LONG')
                append!(strat.events, signal)
                strat.bought[ticker] = true
            end
        end
    end
end
